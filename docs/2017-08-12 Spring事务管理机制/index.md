# Spring事务管理机制

---

### 事务隔离级别

* READ_UNCOMMITED：允许读取还未提交的改变了的数据，可能导致脏读、幻读、不可重复读。
* READ_COMMITED：允许在并发事务已经提交后读取，可防止脏读，但幻读和不可重复读仍会发生。
* REPEATABLE_READ：对相同字段的多次读取是一致的，除非数据被事务本身改变，可防止脏读、不可重复读，但是幻读仍然可能发生。
* SERIALIZABLE：完全服从ACID的隔离级别，确保不发生脏读、幻读、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。

脏读、不可重复读、幻读：

* 脏读：一个事务读取了另一个事务改写但还未提交的数据；如果这些数据被回滚，则读到的数据是无效的。
* 不可重复读：在同一事务中，多次读取同一数据返回的结果有所不同。换句话说，后续读取可以读到另一事务已提交的更新数据。相反，可重复读在同一事务中多次读取数据时，能够保证所读数据一致，也就是说，后续读取不能读到另一事务已提交的更新数据。
* 幻读：一个事务读取了几行记录后，另一个事务插入了一些记录，幻读就发生了。在后来的查询中，第一个事务就会发现有些原来没有的记录。

### 事务传播行为

* 问题1：取钱时没有出现问题，但打印凭条的时候出现机器故障，此时事务是否需要回滚？两个事务，取钱事务不用回滚。
* 问题2：删除客户信息没问题，但订单删除出现问题，事务是否需要回滚？两个事务，删除客户的事务应该回滚。

事务传播行为用于解决两个被事务管理的方法互相调用的问题。事务的传播行为有7种类型：

* PROPAGATION_REQUIRED：支持当前事务，如果不存在，就新建一个；
* PROPAGATION_SUPPORTS：支持当前事务，如果不存在，就不使用事务；
* PROPAGATION_MANDATORY：支持当前事务，如果不存在，抛出异常；
* PROPAGATION_REQUIRES_NEW：如果有事务存在，挂起当前事务，创建一个新的事务；
* PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务；
* PROPAGATION_NEVER：以非事务方式运行，如果有事务存在，抛出异常；
* PROPAGATION_NESTED：如果当前事务存在，则嵌套事务执行（只对DataSourceTransactionManager起效）；

可以将这7种传播行为分为3大类：

* PROPAGATION_REQUIRED（默认值）、PROPAGATION_SUPPORTS、PROPAGATION_MANDATORY：支持当前事务，如A调用B，如果A事务存在，则B和A处在同一个事务。（如上面问题2）
* PROPAGATION_REQUIRES_NEW、PROPAGATION_NOT_SUPPORTED、PROPAGATION_NEVER：不会支持原来的事务，如A调用B，如果A事务存在，B肯定不会和A处在同一个事务。（如上面问题1）
* PROPAGATION_NESTED：嵌套事务，底层使用JDBC的SavePoint机制，允许在同一个事务设置保存点、回滚保存点。



<br/><br/><br/>

---

